{"version":3,"file":"NsisUpdater.js","sourceRoot":"","sources":["../src/NsisUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, newError, PackageFileInfo, BlockMap, CURRENT_APP_PACKAGE_FILE_NAME, CURRENT_APP_INSTALLER_FILE_NAME } from \"builder-util-runtime\"\nimport { spawn } from \"child_process\"\nimport * as path from \"path\"\nimport { AppAdapter } from \"./AppAdapter\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater, InstallOptions } from \"./BaseUpdater\"\nimport { DifferentialDownloaderOptions } from \"./differentialDownloader/DifferentialDownloader\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { GenericDifferentialDownloader } from \"./differentialDownloader/GenericDifferentialDownloader\"\nimport { DOWNLOAD_PROGRESS, ResolvedUpdateFileInfo } from \"./main\"\nimport { blockmapFiles } from \"./util\"\nimport { findFile, Provider } from \"./providers/Provider\"\nimport { unlink } from \"fs-extra\"\nimport { verifySignature } from \"./windowsExecutableCodeSignatureVerifier\"\nimport { URL } from \"url\"\nimport { gunzipSync } from \"zlib\"\n\nexport class NsisUpdater extends BaseUpdater {\n  /**\n   * Specify custom install directory path\n   *\n   */\n  installDirectory?: string\n\n  constructor(options?: AllPublishOptions | null, app?: AppAdapter) {\n    super(options, app)\n  }\n\n  /*** @private */\n  protected doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = downloadUpdateOptions.updateInfoAndProvider.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"exe\")!\n    return this.executeDownload({\n      fileExtension: \"exe\",\n      downloadUpdateOptions,\n      fileInfo,\n      task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {\n        const packageInfo = fileInfo.packageInfo\n        const isWebInstaller = packageInfo != null && packageFile != null\n        if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {\n          throw newError(\n            `Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`,\n            \"ERR_UPDATER_WEB_INSTALLER_DISABLED\"\n          )\n        }\n        if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {\n          this._logger.warn(\n            \"disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.\"\n          )\n        }\n        if (isWebInstaller || (await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider))) {\n          await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions)\n        }\n\n        const signatureVerificationStatus = await this.verifySignature(destinationFile)\n        if (signatureVerificationStatus != null) {\n          await removeTempDirIfAny()\n          // noinspection ThrowInsideFinallyBlockJS\n          throw newError(\n            `New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`,\n            \"ERR_UPDATER_INVALID_SIGNATURE\"\n          )\n        }\n\n        if (isWebInstaller) {\n          if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo!, packageFile!, provider)) {\n            try {\n              await this.httpExecutor.download(new URL(packageInfo!.path), packageFile!, {\n                headers: downloadUpdateOptions.requestHeaders,\n                cancellationToken: downloadUpdateOptions.cancellationToken,\n                sha512: packageInfo!.sha512,\n              })\n            } catch (e) {\n              try {\n                await unlink(packageFile!)\n              } catch (ignored) {\n                // ignore\n              }\n\n              throw e\n            }\n          }\n        }\n      },\n    })\n  }\n\n  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\\yyy.exe'\n  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains(\"CN=siemens.com\")})\n  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }\n  private async verifySignature(tempUpdateFile: string): Promise<string | null> {\n    let publisherName: Array<string> | string | null\n    try {\n      publisherName = (await this.configOnDisk.value).publisherName\n      if (publisherName == null) {\n        return null\n      }\n    } catch (e) {\n      if (e.code === \"ENOENT\") {\n        // no app-update.yml\n        return null\n      }\n      throw e\n    }\n    return await verifySignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, this._logger)\n  }\n\n  protected doInstall(options: InstallOptions): boolean {\n    const args = [\"--updated\"]\n    if (options.isSilent) {\n      args.push(\"/S\")\n    }\n\n    if (options.isForceRunAfter) {\n      args.push(\"--force-run\")\n    }\n\n    if (this.installDirectory) {\n      // maybe check if folder exists\n      args.push(`/D=${this.installDirectory}`)\n    }\n\n    const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile\n    if (packagePath != null) {\n      // only = form is supported\n      args.push(`--package-file=${packagePath}`)\n    }\n\n    const callUsingElevation = (): void => {\n      _spawn(path.join(process.resourcesPath!, \"elevate.exe\"), [options.installerPath].concat(args)).catch(e => this.dispatchError(e))\n    }\n\n    if (options.isAdminRightsRequired) {\n      this._logger.info(\"isAdminRightsRequired is set to true, run installer using elevate.exe\")\n      callUsingElevation()\n      return true\n    }\n\n    _spawn(options.installerPath, args).catch((e: Error) => {\n      // https://github.com/electron-userland/electron-builder/issues/1129\n      // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors\n      const errorCode = (e as NodeJS.ErrnoException).code\n      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: \"${e.message}\", will be executed again using elevate if EACCES\"`)\n      if (errorCode === \"UNKNOWN\" || errorCode === \"EACCES\") {\n        callUsingElevation()\n      } else {\n        this.dispatchError(e)\n      }\n    })\n    return true\n  }\n\n  private async differentialDownloadInstaller(\n    fileInfo: ResolvedUpdateFileInfo,\n    downloadUpdateOptions: DownloadUpdateOptions,\n    installerPath: string,\n    provider: Provider<any>\n  ): Promise<boolean> {\n    try {\n      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {\n        return true\n      }\n      const blockmapFileUrls = blockmapFiles(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version)\n      this._logger.info(`Download block maps (old: \"${blockmapFileUrls[0]}\", new: ${blockmapFileUrls[1]})`)\n\n      const downloadBlockMap = async (url: URL): Promise<BlockMap> => {\n        const data = await this.httpExecutor.downloadToBuffer(url, {\n          headers: downloadUpdateOptions.requestHeaders,\n          cancellationToken: downloadUpdateOptions.cancellationToken,\n        })\n\n        if (data == null || data.length === 0) {\n          throw new Error(`Blockmap \"${url.href}\" is empty`)\n        }\n\n        try {\n          return JSON.parse(gunzipSync(data).toString())\n        } catch (e) {\n          throw new Error(`Cannot parse blockmap \"${url.href}\", error: ${e}`)\n        }\n      }\n\n      const downloadOptions: DifferentialDownloaderOptions = {\n        newUrl: fileInfo.url,\n        oldFile: path.join(this.downloadedUpdateHelper!.cacheDir, CURRENT_APP_INSTALLER_FILE_NAME),\n        logger: this._logger,\n        newFile: installerPath,\n        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n        requestHeaders: downloadUpdateOptions.requestHeaders,\n        cancellationToken: downloadUpdateOptions.cancellationToken,\n      }\n\n      if (this.listenerCount(DOWNLOAD_PROGRESS) > 0) {\n        downloadOptions.onProgress = it => this.emit(DOWNLOAD_PROGRESS, it)\n      }\n\n      const blockMapDataList = await Promise.all(blockmapFileUrls.map(u => downloadBlockMap(u)))\n      await new GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1])\n      return false\n    } catch (e) {\n      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n      if (this._testOnlyOptions != null) {\n        // test mode\n        throw e\n      }\n      return true\n    }\n  }\n\n  private async differentialDownloadWebPackage(\n    downloadUpdateOptions: DownloadUpdateOptions,\n    packageInfo: PackageFileInfo,\n    packagePath: string,\n    provider: Provider<any>\n  ): Promise<boolean> {\n    if (packageInfo.blockMapSize == null) {\n      return true\n    }\n\n    try {\n      const downloadOptions: DifferentialDownloaderOptions = {\n        newUrl: new URL(packageInfo.path),\n        oldFile: path.join(this.downloadedUpdateHelper!.cacheDir, CURRENT_APP_PACKAGE_FILE_NAME),\n        logger: this._logger,\n        newFile: packagePath,\n        requestHeaders: this.requestHeaders,\n        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n        cancellationToken: downloadUpdateOptions.cancellationToken,\n      }\n\n      if (this.listenerCount(DOWNLOAD_PROGRESS) > 0) {\n        downloadOptions.onProgress = it => this.emit(DOWNLOAD_PROGRESS, it)\n      }\n\n      await new FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download()\n    } catch (e) {\n      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n      // during test (developer machine mac or linux) we must throw error\n      return process.platform === \"win32\"\n    }\n    return false\n  }\n}\n\n/**\n * This handles both node 8 and node 10 way of emitting error when spawning a process\n *   - node 8: Throws the error\n *   - node 10: Emit the error(Need to listen with on)\n */\nasync function _spawn(exe: string, args: Array<string>): Promise<any> {\n  return new Promise((resolve, reject) => {\n    try {\n      const process = spawn(exe, args, {\n        detached: true,\n        stdio: \"ignore\",\n      })\n      process.on(\"error\", error => {\n        reject(error)\n      })\n      process.unref()\n\n      if (process.pid !== undefined) {\n        resolve(true)\n      }\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n"]}